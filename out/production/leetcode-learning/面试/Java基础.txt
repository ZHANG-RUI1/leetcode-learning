1.谈谈你对Java平台的理解？“Java是解释执行”这句话正确吗？
        在我的印象中，Java平台是一个庞大的并且可靠的语言体系，在应用层面，有各种优秀的框架和解决方案为其服务，用于处理企业在生产环境中
    遇到的各种复杂问题，例如：Spring体系、Handoop、spark，ElasticSearch、Maven等。在Java语言自身层面,它的语法特性像面向对象、反射
    等，还有一些核心类库，例如：Collection, Map, IO/NIO，Concurrent包等，还有他的异常体系，这解决了很多应用问题。而从JVM虚拟机层面
    来说，Java的 write once, run anywhere正来源于此，虚拟机实现了Java的跨平台能力，并且通过垃圾收集器为Java管理内存，让使用者不再为
    分配和回收内存而操心，只需要专注于代码业务逻辑的实现。
        而对于“Java是解释执行”这句话，我认为这种说法不够准确，虽然我们开发的源代码通过Javac编译成二进制字节码文件，再通过虚拟机内嵌
    的解释器进行解释执行。但目前主流的Java虚拟机，比如Hotspot,都采用了JIT即时编译器，也就是通常所说的动态编译器。它可以在运行时将热点
    代码编译成机器码，这种情况下，这部分代码就属于编译执行。


2.请对比Exception和Error，另外，运行时异常和一般异常有什么区别？
        在Java的异常体系中，只有Throwable（或者其子类）的实例才可以进行异常处理（抛出或者捕获处理），而它有两个直接的异常子类
    Exception和error。error表明出现严重问题，描述的是Java运行时系统的内部错误和资源耗尽错误（递归可能出现），通常不进行异常处理，如：
    NoClassDefFoundError,OutOfMemoryError等。而Exception表示程序中出现的普通问题，通常是代码存在问题，分为运行时异常
    （RuntimeException）和一般异常。
        在Java中，把运行时异常（RuntimeException）和Error类派生的所有类称为非受查异常，因此运行时异常是非受查异常，通常由代码的逻辑
    错误导致，根据需要，判断是否需要进行异常处理，例如：数组越界（ArrayIndexOutOfBoundsException）,空指针异常（
    NullPointerException），并发修改异常（ConcurrentModificationException）等等；而Exception中的一般异常是受查异常，有时也被称为
    编译期异常，必须进行异常处理，否则编译无法通过，例如：IOException,ClassNotFoundException 。

    2.1 NoClassDefFoundError和ClassNotFoundException的区别？
        NoClassDefFoundError是Error的派生类，属于非受查异常，不用进行异常处理，发生在编译完成后，虚拟机在准备执行字节码文件时，通过
    类加载器在classpath下加载字节码文件时发现找不到对应类时。ClassNotFoundException属于运行时异常，是受查异常，必须进行异常处理，例
    如：Class.forName的时候。


3.谈谈final、finally、finalize有什莫不同？
        final可以用来修饰类、方法、变量，分别有着不同的意义；修饰类时表明此类是无法被继承扩展的（如:String类），修饰方法时，表明此方法
    不能被重写，而修饰变量，此变量只能赋值一次，也就是常量，final修饰的类变量，在准备阶段就被赋值（饿汉式单例模式中）。List.of创建一个
    不可变的List。
        finally存在于Java的异常处理体系中，用于保证重点代码必须被执行的机制中，如try-finally,try-catch-finally，常用于关闭资源
    JDBC，解锁unlock等场景下。
        finalize是基类Object的一个方法。它可以在垃圾收集前执行，设计目的是保证对象在垃圾收集前完成特定的资源回收，JDK9已经将其标为过
    时方法。


4.强引用、软引用、弱引用、虚引用的区别？
    强引用：普通对象引用，表明对象活着，垃圾收集器不会回收，用于普通赋值；
    软引用：1.2提供软引用类，非必要对象，内存不足时垃圾收集器会回收此类对象，用于实现内存敏感的缓存；
    弱引用：1.2提供弱引用类，非必要对象，下一次垃圾回收时会回收此类对象，用于提供一种对象的访问途径或缓存实现；
    虚引用（幻引用）：1.2提供弱引用类，最弱的引用关系，唯一用于对象被回收时收到系统的通知


5.String、StringBuiler、Stringbuffer有什么区别？
    String为不可变类，由final修饰，因此对于它的拼接、剪切等，都会产生新的对象。由于对字符串的操作往往较多，因此性能不太好；
    StringBuilder底层使用可变数组，解决了String中字符串拼接操作产生太多中间对象的问题，不保证线程安全，性能最高。
    StringBuffer,相比于StringBuilder，加上了线程安全的部分。

    5.1.字符串对象创建
        String str1 = "123": 创建0或1个对象。
            当常量池存在此值时，不创建对象，直接将引用赋值给str1；不存在时，常量池中创建一个字符串对象，并将引用赋值给str1。
        String str2 = new String("123"): 创建1或者2个对象，但值只使用同一份。
            当常量池存在此值时，只在堆内创建1个对象，值指向常量池中的值；不存在时，先在常量池中创建一个字符串对象，再在堆中创建一个对象
        对象的值指向常量池中的值。
        String str3 = "abc" + "def": 虚拟机会在程序编译期优化为连接后的值，因此，创建0/1个对象。
        String str4 = "abc" + new String("def")：编译优化为：
            String s = new String("def"); new StringBuilder.append("abc").append(s).toString);
            创建对象5个：常量池2个，堆1个，StringBuilder1个。（常量池未存储"abcdef",尚存在疑问）。

    5.2.intern方法的作用String str5 = str4.intern()
        调用intern方法，当字符串存在于常量池中时，将字符串引用赋值；当不存在时，在常量池中创建一个字符串对象，并将其引用进行赋值。


6.谈谈Java的反射机制，动态代理是基于什么原理
        Java中的反射机制是指动态获取类信息或者动态调用对象方法的机制。在运行状态中，对于任意一个类都可知其属性和方法，对任意一个对象，
    都可调用其任意一个属性或者方法。它可以在运行时加载、探知、使用编译期完全未知的类。
        反射的应用： Spring中的JdkProxy,

        动态代理是一种基于代理模式动态构建代理的机制，常见的有两种动态代理的实现方式有jdkProxy和cglib.
        代理模式：为其他对象提供一个代理对象，通过代理对象来控制访问目标对象。
        jdkProxy原理：让代理类持有已经实现某个接口的target类的实例对象，通过反射机制对实例对象进行操作，生成一个代理对象。
        cglib原理：通过ASM(字节码生成技术)动态生成被代理类的子类，作为它的代理对象


7.int和Integer的区别：
        1.从类型上说，int为基本类型， 可以直接使用；Integer为包装类型，需要创建实例对象才能使用。
        2.从数据存储方面来说，int初始值为0；Integer初始值为null另外，Integer中还有缓存机制，缓存-128~127之间的数


8.解决Hash冲突的三种方法
    1.开放地址法
        当冲突时按照某种方法继续探测哈希表中其他的存储单元，直到找到空位置。探测法有线性探测（依次向后），二次探测（跳跃左右寻找），
            伪随机探测（给定一个随机数做起点）
    2.再哈希法  有多个Hash函数，当冲突后，变换hash函数，直到不再冲突，这种方法，当数据较多时，大大增加的计算时间
    3.链地址法  当冲突发生后，为哈希值相同的数据创建一个链表，适用于经常进行插入和删除的情况（Java中HashMap的实现方式）
    4.建立公共溢出区  就是将Hash表分为基本表和溢出表两部分，冲突的元素一律填入溢出表


9.Array.sort()的底层原理
        Array.sort()的排序实现是插入排序，快速排序，归并排序的组合，当数据量小于47则使用插入排序，当大于286时，看数据是否相对有规律，
    是，则使用归并排序，否则，继续使用快排，在设计模式上采用策略模式。


10.创建对象的几种方式
   1.使用new关键字
         List<Integer> list = new ArrayList<Integer>();
   2.使用反射
        使用类对象创建实例
            ArrayList list = (ArrayList)Class.forName("java.util.ArrayList").newInstance();
            ArrayList list = ArrayList.class.newInstance();
        使用构造器创建实例
            Constructor<ArrayList> con = ArrayList.class.getConstructor();
            ArrayList list = con.newInstance();
   3.使用clone方式,不调用构造器
            ArrayList que2 =(ArrayList) que.clone();
   4.使用流对象，被创建的类必须实现Serializable接口


11.引用传递和值传递，
    值传递：
        方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，
    即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值，例如基本类型。

    引用传递：
        也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；
    在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象，例如引用类型。


12.类初始化和实例初始化
    类初始化过程：
        1.类要实例化必须先加载并初始化，main方法所在的类优先加载和初始化
        2.子类初始化前需要先初始化父类
        3.类初始化就是执行clinit方法，只会一次，clinit方法中包含静态变量和静态代码块
        4.静态变量和静态代码块按上下顺序执行
    实例初始化（实例初始化就是执行init方法（先执行父类的init方法））
        1》有几个构造器就有几个init方法,可能重载了多个
        2》init方法有非静态变量赋值、非静态代码块、构造器组成
        3》非静态变量赋值和非静态代码块从上到下执行，构造器最后执行
        4》init方法的开头调用对应的父类的init方法
    方法重写
        1.不可以被重写的方法
            final方法
            静态方法
            private等子类不可见的方法
        2.对象的多态性
            子类重写了父类的方法，通过子类对象调用的一定是子类的重写过的代码
            非静态方法默认调用的对象是this


13.谈谈接口和抽象类有什么区别？
    接口和抽象类是Java面向对象的基础机制。
    1.从他们的内容上来理解:
        抽象类是对一种事物的抽象，即对类的抽象，它可以有抽象方法，也可以有方法的实现(非静态，非默认的方法);
        而接口是对行为的抽象，也就是方法的抽象，只能有抽象方法（非静态，非默认方法,在jdk9中接口中又引入了私有方法，和私有静态方法）。

    2.从继承机制上讲，一个类可以实现多个接口，但只能继承一个抽象类。接口也可以继承多个接口口
    13.1
        接口：1.是对对象的行为抽象；
             2.不能实例化，不能有非静态的方法实现
             3.接口可以进行多继承，一个类也可以实现多个接口
             4.利用接口可以抽取方法集合，以达到API定义和接口实现进行分离，有助于代码的复用和维护，例如：Comparator、serializable接口等。
        抽象类：1.对事物对象的抽象
               2.也不能被实例化，但是可以有抽象方法，也可以有方法实现；
               3.由于是类，只能继承一个父类
               4.可以用于抽取相关类中共有的方法实现，或者变量，通过继承，达到代码复用的目的，例如：AbstractList。


14.谈谈你知道的设计模式？请手动实现单例模式，Spring等框架中使用了哪些模式？
        按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。
        创建型模式是对对象创建过程的各种问题和解决方案的总结：
            包括工厂模式、单例模式、原型模式、构建器模式。
        结构型模式是对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验：
            包括装饰者模式、适配器模式、代理模式、享元模式、桥接模式、组合模式、外观模式。
        行为型模式是从类或者对象之间的交互、职责划分等角度总结的模式：
            包括策略模式、解释器模式、命令模式、观察者模式、迭代器模式、模板方法模式、访问者模式。
        1》饿汉模式
        public class Singleton{
            public static final Singleton NEWINSTANCE = new Singleton();
            private static Singleton(){};
        }
        在Spring中，设计模式的应用也非常多，例如在BeanFactory和ApplicationContext中应用的工厂模式、在bean创建过程中使用的单例模式
    和原型模式、SpringAOP通过代理模式实现将切面代码植入业务中、Spring中的各种监听器是观察者模式的典型应用，等等。


15.为什么要重写hashCode()方法和equals()方法以及如何进行重写
        由于Object类中的equals方法，在未被重写前比较某两个对象是否相等的方式就是==，即比较地址引用是否相同。通常，这种比较的意义不大，
    因为，需要比较的往往是不同对象，我们需要设定一定的规则来区分不同的对象，例如：对于Student类，只要知道两个学生对象的有一样的学号，
    就可以确定是同一个学生。因此需要重写equals方法。
        而重写equals方法必须重写hashCode方法的前提是需要将对象插入散列表，如Java中的HashMap、HashSet。如果不使用散列表的话，仅重写
    equals方法也可以。

    15.1java中==和equals和hashCode的区别
        ==是运算符，用来比较两个值、两个对象的内存地址是否相等， 基本类型比较数据，引用类型比较引用
        equals方法用于比较两个对象是否相同，通常需要重写
