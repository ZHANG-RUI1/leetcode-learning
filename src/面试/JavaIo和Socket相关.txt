1.对象序列化机制是什么？
        指将内存中的Java对象转换成二进制序列，可将其保存到磁盘，或者发送给另一个主机。例如：多个项目进行RPC调用需要传输对象时。
    也可将获取到的此类二进制序列恢复成原来的java对象。

    1.1.序列化算法的底层实现
        通过调用OjectOutputStream的WriteObject方法实现.
        其步骤有4个：
            1>先输出实例相关的类描述信息(类的全限路名、属性等)
            2>再递归输出类的父类的描述信息
            3>当类的描述信息输出完后，开始从最顶层的父类输出对象实例数据
            4>从上至下递归输出实例数据
    1.2.序列号id的作用
        Java的序列化机制在运行时判断类的序列号来验证版本一致性，反序列化时，通过二进制序列中的id值与本地实体类中的id值进行比对，若一致
    则可进行反序列化，若不一致则反序列化失败。



2.浅拷贝与深拷贝
	1. 浅拷贝：对基本数据类型进行值复制，对引用数据类型进行引用的拷贝，此为浅拷贝。
	2. 深拷贝：对基本数据类型进行值复制，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝
	    而在java中,深拷贝和浅拷贝都指的是对象拷贝，即对一个类的实例对象进行拷贝，Object类中的clone方法默认实现浅拷贝，当一个实例对象
	调用从Object类继承而来的默认clone方法拷贝对象时（必须在实例对象的类文件下，否则，需要重新定义clone方法），只复制主对象，不复制主
	对象中存在的子对象，即对基本数据类型进行值复制，引用类类型则还是指向原来的对象。而深拷贝则是既需要复制主对象，还要复制子对象，需要
	进行深拷贝时则需要重新定义clone方法。

	注意：在重新定义clone方法时，要将其默认的方法修饰符protected 修改为public.
	    protected的可见范围：
	        1.基类的 protected 成员是包内可见的，并且对子类可见；
            2.若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的
        protected方法。
        参考：https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html


3.什么是socket？
    在两台机器间建立一个网络连接的通道，使其可以相互的发送数据。


4.BIO,NIO和AIO的区别
      BIO
          BIO为同步阻塞I/O模式（也称为传统IO）,基于流，指一个线程在执行I/O操作时，需要等待I/O操作的完成，程序才能继续执行，这段时间线程
      阻塞不能做其他事情，它的Socket通信通过Socket和ServerSocket实现，适用于低负载、低并发的情况。
          BIO Socket多线程模型传输简介：
              数据的收发通过socket获取输入输出流来完成，客户端通过socket来连接服务端,服务端则通过ServerSocket负责监听指定端口的
          连接请求，连接成功后，双方通过输入输出流进行通信。在数据的发送和接受过程中，双方调用SocketAPI读写的线程都会被阻塞，直到接受或
          发送完成。客户端发送请求后，服务端使用一个专门的Acceptor线程不断循环调用ServerSocket的accept()方法，来检查并接受新的连接,一
          旦有新的连接，该方法返回与这个连接相对应的Socket对象,Acceptor线程接着会创建一个处理线程，并将这个新的对象传递给这一个处理线程，
          并在之后由处理线程通过对Socket对象的读写与客户端进行通信。

          问题：
              1.单线程时，每次只能处理一个请求，只有当前请求处理完成才能处理下一个，无法并发处理多个请求。
              2.每建立一个连接就需要开启一个线程，而开启线程和线程的上下文切换非常消耗系统资源，并且服务器可开启的线程数量有限，因此，当
          客户数量大时，会开启大量线程，服务器压力太大，性能会很差。

          阻塞位置：accept(),read();

      NIO
          NIO为同步非阻塞模式。基于通道和缓冲区，在一个线程进行读操作时，总是只读当前可用的数据，当暂时没有数据时，就不执行，而不会阻塞等
      待。此时线程可以做其他事情，同样，写操作也不需要底层的I/O操作完成，其Socket通信通过SeverSocketChannel和SocketChannel实现，适用
      于高负载、高并发的情况。

          NIO模型简介：
              NIO包括三大部分Channel（通道）、Buffer（缓冲区）、Selector(多路复用器)。数据输入输出基于缓冲区和通道，服务端通过
          SeverSocketChannel将监听指定端口连接请求的任务事件注册到Selector中，客户端通过SocketChannel连接到服务端，并发送数据到服务端，
          服务端通过Selector多路复用器，阻塞轮询挑选需要进行处理的事件，并对事件进行同步处理。

          多路复用：
              在一个线程中处理多个读写请求
          通道：
              可以同时进行读写操作。
          解决问题：
              1.让accept()和read()不再阻塞
              2.实现单线程的并发问题
      AIO
          AIO，也称NIO2.0,是Java对于NIO的改进，主要是增加了异步非阻塞I/O的能力，它可以实现由操作系统完成I/O操作后主动通知调用者，即程
      序发起I/O操作后，可以做其他事情，无需阻塞，当操作完成后由操作系统将操作结果交给调用程序进行处理。


5.Java中的三种类型的Socket通信
      1.Socket和ServerSocket
      2.SocketChannel和ServerSocketChannel
      3.AsychronousSocketChannel和AsychronousServerSocketChannel

6.同步、异步、阻塞和非阻塞
    同步、异步指通讯模式
    阻塞、非阻塞指线程处理模式


