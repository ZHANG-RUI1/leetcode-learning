1.为什么使用线程池？
    1.线程复用，通过重复利用已经创建的线程降低线程的创建和销毁，降低资源消耗。
    2.提高响应速度，当任务到达时不需要等待创建线程就可以直接执行。
    3.提高线程的可管理性，可以对线程进行统一的分配，调优和监控。如避免线程无限制创建。


2.线程池的实现？
    线程池的顶层接口为Executor,通过ThreadPoolExecutor实现


3.有几种线程池？
        Executors提供了三种线程池的实现，分别是newFixedThreadPool(固定线程池),newCachedThreadPool(可扩展线程池),
    newSingleThreadExecutor(单线程线程池)。阿里开发手册 7个参数。
    Executors各个方法的弊端：

    1） newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队
        列可能会耗费非常大的内存，甚至OOM。

    2） newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是
        Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。


4.并行和并发的区别？
    并行：指同一时间，多个任务同时运行。
    并发：指多个任务轮流执行。


5.线程个数设置
    CPU 密集型运算
        通常采用：  线程个数 = cpu 核数 + 1
        能够实现最优的CPU利用，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程保证CPU时钟周期不浪费。
    I/O密集型运算
        由于IO运算时CPU不用进行运算,这时可以使用更多的线程提高CPU的利用率。
        通常采用：  线程个数 = cpu 核数 * （1 / CPU执行时间占总时间的百分比）

    总结：越需要cpu运行的任务，线程要越少。



6.线程状态简述？
    操作系统层面将线程状态分为5种，新建、就绪、运行、阻塞、结束。
    JavaAPI层面将线程状态分为6种，NEW、RUNNABLLE、BOLCKED、WAITTING、TIME_WAITTING、TERMINATED。
    JavaAPI将阻塞状态细分为BOLCKED、WAITTING、TIME_WAITTING；将运行状态、可运行状态、IO阻塞包含在了RUNNABLE中。

    6.1.处于阻塞状态的情况？
        获取锁失败
        BIO时


7.进程和线程的区别？
    在我的理解中，进程像是一个容器，是系统资源分配的基本单元，而线程是一个具体执行的任务，是系统任务调度的基本单元。



8.创建线程的三种方式？
    1.直接使用Thread
    2.使用Runnable配合Thread
    3.FutureTask配合Thread


9.Linux或Mac查看线程的方式：
    top 1
    kill -3  XXX   给进程发送3的信号

10.守护线程


11.join和wait的区别？
    t.join() 当前线程不会释放已经持有的对象锁，因为内部调用了t.wait，所以会释放t这个对象上的同步锁
    ** multithread.method.Join


12.volatile
    volatile 保证可见性和一定的有序性，但并不能保证原子性。


13.final

14.jstack -l 查看锁的状态

15.只run一下main函数，JVM 应该有5个线程

16.可重入锁
    同一线程可重复拿到锁


17.公平锁和非公平锁
    公平锁：按排队顺序执行
    非公平锁：随机执行


18.读写锁 （可用于读写锁）
    共享锁：多个线程可以同时持有
    排他锁：一个线程独占


19.park

20.LockSupport--锁当前线程

21.用锁原则
    Doug Lea《Java 并发编程：设计原则与模式》一书中，提到了三个最佳实践：
        1.永远只在更新对象成员变量时加锁
        2.永远只在访问可变对象变量时加锁
        3.永远不在调用其他对象方法时加锁
    总结：
        1.减小锁范围：尽量锁更少行数的代码
        2.降低锁粒度：一个大锁可拆成多个小锁

22.Atomic--工具类
    1.无锁技术（乐观锁）的底层原理实现：
        1.通过volatile保证读写操作的可见性。
        2.通过CAS指令实现自旋重试，保证写入。
        CAS本质上没有使用锁。
            并发压力跟锁性能的关系：
            1、压力非常小，性能本身要求就不高；
            2、压力一般的情况下，无锁更快，大部分都一次写入；
            3、压力非常大时，自旋导致重试过多，资源消耗很大。
    2.CAS的三大问题
        1.ABA问题
            通过版本号解决 Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题
        2.循环时间长开销大
            在cpu资源竞争非常激烈的时候不使用CAS
        3.只能保证一个共享变量的原子性
            1》使用锁
            2》jdk1.5开始提供AtomReference保证对象的原子性，可以将多个变量放入此对象进行操作。
            3》将两个变量合成一个s


23.LongAdder 对 AtomicLong 的改进思路：
   1、AtomicInteger和AtomicLong里的value是所有线程竞争读写的热点数据；
   2、将单个value拆分成跟线程一样多的数组Cell[]；
   3、每个线程写自己的Cell[i]++，最后对数组求和。


24.AQS(AbstractQueuedSynchronizer) 抽象队列同步器简介
        AQS是一个构建锁和同步器的框架，它抽象了竞争资源和线程队列。基于AQS的实现包括ReentrantLock、semaphore、
    CountDownLauntch、和ReentrantLock等. 至少包含两种类型的操作，acquire(),release().


25.三种常用的工具类
    Semaphore
        使用场景：同一时间控制并发线程数
    CountDownLatch
        场景: Master 线程等待 Worker 线程把任务执行完(阻塞主线程，N个子线程满足条件时主线程继续。)
    CyclicBarrier
        每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行
    CountDownLatch和CyclicBarrier区别
            CountDownLatch在主线程await阻塞并做聚合，同步点在主线程；CyclicBarrier在每个子线程await()回调聚合，
        最后到达同步点的线程执行。




s










